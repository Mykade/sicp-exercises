<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>sicp-chapter-1</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="sicp-chapter-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-04-13T23:49+0800"/>
<meta name="author" content="yuen"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">sicp-chapter-1</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Exercise 1.1.</a></li>
<li><a href="#sec-2">2 Exercise 1.2.</a></li>
<li><a href="#sec-3">3 Exercise 1.3.</a></li>
<li><a href="#sec-4">4 Exercise 1.4.</a></li>
<li><a href="#sec-5">5 Exercise 1.5.</a></li>
<li><a href="#sec-6">6 Exercise 1.6.</a></li>
<li><a href="#sec-7">7 Exercise 1.7.</a></li>
<li><a href="#sec-8">8 Exercise 1.8.</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Exercise 1.1.</h2>
<div class="outline-text-2" id="text-1">


<p>
  Below is a sequence of expressions. What is the result printed by the
  interpreter in response to each expression? Assume that the sequence is
  to be evaluated in the order in which it is presented.
</p>



<pre class="src src-scheme">10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(<span style="color: #859900; font-weight: bold;">define</span> <span style="color: #268bd2;">a</span> 3)
(<span style="color: #859900; font-weight: bold;">define</span> <span style="color: #268bd2;">b</span> (+ a 1))
(+ a b (* a b))
(= a b)
(<span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #859900; font-weight: bold;">and</span> (&gt; b a) (&lt; b (* a b)))
    b
    a)
(<span style="color: #859900; font-weight: bold;">cond</span> ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (<span style="color: #859900; font-weight: bold;">else</span> 25))
(+ 2 (<span style="color: #859900; font-weight: bold;">if</span> (&gt; b a) b a))
(* (<span style="color: #859900; font-weight: bold;">cond</span> ((&gt; a b) a)
         ((&lt; a b) b)
         (<span style="color: #859900; font-weight: bold;">else</span> -1))
   (+ a 1))
</pre>



<pre class="example">10
12
8
3
6
19
#f
4
16
6
16
</pre>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Exercise 1.2.</h2>
<div class="outline-text-2" id="text-2">


<p>
  Translate the following expression into prefix form
</p>
<p>
<img src="exercise-1.2.png"  alt="exercise-1.2.png" />
</p>


<pre class="src src-scheme">(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
</pre>


<pre class="example">
-37/150
</pre>


</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Exercise 1.3.</h2>
<div class="outline-text-2" id="text-3">


<p>
  Define a procedure that takes three numbers as arguments and returns the sum
  of the squares of the two larger numbers.
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">bigger</span> x y)
  (<span style="color: #859900; font-weight: bold;">if</span> (&gt; x y) x y))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">smaller</span> x y)
  (<span style="color: #859900; font-weight: bold;">if</span> (&lt; x y) x y))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">bigger-sum</span> a b c)
  (+ (sqr (bigger a b)) (sqr (bigger (smaller a b) c))))

(bigger-sum 1 2 3)
</pre>


<pre class="example">
13
</pre>



</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Exercise 1.4.</h2>
<div class="outline-text-2" id="text-4">


<p>
  Observe that our model of evaluation allows for combinations whose operators
  are compound expressions. Use this observation to describe the behavior of the
  following procedure:
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">a-plus-abs-b</span> a b)
  ((<span style="color: #859900; font-weight: bold;">if</span> (&gt; b 0) + -) a b))

(a-plus-abs-b 1 1)
(a-plus-abs-b 1 -1)
</pre>


<pre class="example">
2
2
</pre>


<p>
  定义了一个函数 a-plus-abs-b，有两个参数 a b
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">if</span> (&gt; b 0) + -)
</pre>


<p>
  如果 b 大于 0，那么返回 +，否则返回 -
</p>
<p>
  这里把操作符做为函数的返回值
</p>
<p>
  (op a b)
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Exercise 1.5.</h2>
<div class="outline-text-2" id="text-5">


<p>
  Ben Bitdiddle has invented a test to determine whether the interpreter he is
  faced with is using applicative-order evaluation or normal-order evaluation.
  He defines the following two procedures:
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">p</span>) (p))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">test</span> x y)
  (<span style="color: #859900; font-weight: bold;">if</span> (= x 0)
      0
      y))
</pre>


<p>
Then he evaluates the expression
</p>



<pre class="src src-scheme">(test 0 (p))
</pre>


<p>
  What behavior will Ben observe with an interpreter that uses applicative-order
evaluation? What behavior will he observe with an interpreter that uses
normal-order evaluation? Explain your answer. (Assume that the evaluation rule
for the special form if is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative expression.)
</p>
<p>
  applicative-order: 会在参数传递前进行表达式的执行，即： (test 0 (p))
</p>
<p>
  此时会先分别对表达式 0，(p) 分别求值，表达式 (p) 展开求值进入死循环
</p>
<p>
  normal-order: 会在用到参数时才进行求值，先将 0 和 (p) 带入 (test x y)
</p>
<p>
  此时判断 (if (= x 0) 0 (p)) 先执行 (= x 0) 即: (= 0 0)，直接返回 0 并不再执行(p)
</p>

</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Exercise 1.6.</h2>
<div class="outline-text-2" id="text-6">


<p>
  Alyssa P. Hacker doesn't see why if needs to be provided as a special form.
  ``Why can't I just define it as an ordinary procedure in terms of cond?''
  she asks. Alyssa's friend Eva Lu Ator claims this can indeed be done,
  and she defines a new version of if:
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">new-if</span> predicate then-clause else-clause)
  (<span style="color: #859900; font-weight: bold;">cond</span> (predicate then-clause)
        (<span style="color: #859900; font-weight: bold;">else</span> else-clause)))

<span style="color: #586e75;">; </span><span style="color: #586e75;">Eva demonstrates the program for Alyssa:</span>

(new-if (= 2 3) 0 5)

(new-if (= 1 1) 0 5)

</pre>


<pre class="example">
5
0
</pre>


<p>
Delighted, Alyssa uses new-if to rewrite the square-root program:
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">sqrt-iter</span> guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
</pre>


<p>
What happens when Alyssa attempts to use this to compute square roots? Explain.
</p>
<p>
这里的 new-if 是一个普通的函数，在函数调用时会先对其参数进行求值，
</p>
<p>
这里 new-if 的两个参数分别是函数调用 (goo-enough) 和 (sqrt-iter)，对两个分别进行
求值计算就导致陷入了 (sqrt-iter) 的无限循环内
</p>
<p>
书上有写：
</p>
<p>
(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;) 的求值顺序是从 &lt;predicate&gt; 开始，
</p>
<p>
如果 &lt;predicate&gt; 得到真值，解释器会去求值 &lt;consequent&gt; 并返回其值，
</p>
<p>
否则它就去求值 &lt;alternative&gt; 并返回其值
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">if</span> #t (display <span style="color: #2aa198;">"hello"</span>) (display <span style="color: #2aa198;">"world"</span>))

</pre>


<pre class="example">
hello
</pre>






<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">new-if</span> predicate then-clause else-clause)
  (<span style="color: #859900; font-weight: bold;">cond</span> (predicate then-clause)
        (<span style="color: #859900; font-weight: bold;">else</span> else-clause)))

(new-if #t (display <span style="color: #2aa198;">"hello"</span>) (display <span style="color: #2aa198;">"world"</span>))

</pre>


<pre class="example">
helloworld
</pre>



<p>
牛顿法求平方根的算法:
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">abs</span> x)
  (<span style="color: #859900; font-weight: bold;">if</span> (&lt; x 0) (- 0 x) x))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">square</span> x)
  (* x x))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">good-enough?</span> guess x)
  (display (format <span style="color: #2aa198;">"~a\n"</span> guess))
  (&lt; (abs (- (square guess) x)) 0.0001))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">improve</span> guess x)
  (/ (+ guess (/ x guess)) 2))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">sqrt-iter</span> guess x)
  (<span style="color: #859900; font-weight: bold;">if</span> (good-enough? guess x) guess
      (sqrt-iter (improve guess x) x)))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">sqrt</span> x)
  (sqrt-iter 1.0 x))

(sqrt 9)

(sqrt 0.0000000000000000000009)

</pre>



<pre class="example">1.0
5.0
3.4
3.023529411764706
3.00009155413138
3.000000001396984
3.000000001396984

1.0
0.5
0.25
0.125
0.0625
0.03125
0.015625
0.0078125
0.0078125
</pre>


</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Exercise 1.7.</h2>
<div class="outline-text-2" id="text-7">


<p>
  The good-enough? test used in computing square roots will not be very
  effective for finding the square roots of very small numbers. Also,
  in real computers, arithmetic operations are almost always performed with
  limited precision. This makes our test inadequate for very large numbers.
  Explain these statements, with examples showing how the test fails for small
  and large numbers. An alternative strategy for implementing good-enough?
  is to watch how guess changes from one iteration to the next and to stop when
  the change is a very small fraction of the guess. Design a square-root
  procedure that uses this kind of end test.
  Does this work better for small and large numbers?
</p>
<p>
  针对非常小的数字，我们可以使用优化 good-enough 函数来解决
</p>



<pre class="src src-scheme">(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">abs</span> x)
  (<span style="color: #859900; font-weight: bold;">if</span> (&lt; x 0) (- 0 x) x))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">square</span> x)
  (* x x))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">good-enough?</span> old-guess new-guess)
  (display (format <span style="color: #2aa198;">"~a\n"</span> old-guess))
  (&lt; (/ (abs (- new-guess old-guess)) old-guess) 0.0001))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">improve</span> guess x)
  (/ (+ guess (/ x guess)) 2))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">sqrt-iter</span> guess x)
  (<span style="color: #859900; font-weight: bold;">let</span> ((new-guess (improve guess x)))
    (<span style="color: #859900; font-weight: bold;">if</span> (good-enough? guess new-guess) guess
        (sqrt-iter new-guess x))))

(<span style="color: #859900; font-weight: bold;">define</span> (<span style="color: #268bd2;">sqrt</span> x)
  (sqrt-iter 1.0 x))

(sqrt 0.0000000000000000000009)
</pre>



<pre class="example">1.0
0.5
0.25
0.125
0.0625
0.03125
0.015625
0.0078125
0.00390625
0.001953125
0.0009765625000000002
0.0004882812500000005
0.0002441406250000012
0.00012207031250000244
6.10351562500049e-05
3.0517578125009826e-05
1.5258789062519658e-05
7.629394531289321e-06
3.814697265703643e-06
1.9073486329697864e-06
9.536743167208228e-07
4.768371588322706e-07
2.384185803598537e-07
1.1920929206736365e-07
5.960464980855534e-08
2.9802332454024236e-08
1.4901181326501416e-08
7.450620862198706e-09
3.725370828750545e-09
1.8628062077192604e-09
9.316446748819594e-10
4.663053542092095e-10
2.341177099868953e-10
1.1898096502957087e-10
6.327260009878856e-11
3.8748383309721934e-11
3.098757940327563e-11
3.001573716141363e-11
3.000000412547338e-11
3.000000412547338e-11
</pre>



</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Exercise 1.8.</h2>
<div class="outline-text-2" id="text-8">


<p>
  Newton's method for cube roots is based on the fact that if y is an
  approximation to the cube root of x, then a better approximation is
  given by the value
</p>

<p>
<img src="exercise-1.8.png"  alt="exercise-1.8.png" />
</p>
<p>
  Use this formula to implement a cube-root procedure analogous to the
  square-root procedure.
</p>
<p>
  (In section 1.3.4 we will see how to implement
  Newton's method in general as an abstraction of these square-root and
  cube-root procedures.)
</p></div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-04-13T23:49+0800</p>
<p class="author">Author: yuen</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
